
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Java线程池源码解析及高质量代码案例 | XingLiu&#39;s  Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="XingLiu">
    

    
    <meta name="description" content="本文为Java高级编程中的一些知识总结，其中第一章对Jdk 1.7.0_25中的多线程架构中的线程池ThreadPoolExecutor源码进行架构原理介绍以及源码解析。第二章则分析了几个违反Java高质量代码案例以及相应解决办法。如有总结的不好的地方，欢迎大家提出宝贵的意见和建议。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java线程池源码解析及高质量代码案例">
<meta property="og:url" content="http://pangjiuzala.github.io/2015/11/01/Java线程池源码解析及高质量代码案例/index.html">
<meta property="og:site_name" content="XingLiu's  Blog">
<meta property="og:description" content="本文为Java高级编程中的一些知识总结，其中第一章对Jdk 1.7.0_25中的多线程架构中的线程池ThreadPoolExecutor源码进行架构原理介绍以及源码解析。第二章则分析了几个违反Java高质量代码案例以及相应解决办法。如有总结的不好的地方，欢迎大家提出宝贵的意见和建议。">
<meta property="og:image" content="http://7xiur2.com1.z0.glb.clouddn.com/0376.png">
<meta property="og:updated_time" content="2015-11-09T07:23:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java线程池源码解析及高质量代码案例">
<meta name="twitter:description" content="本文为Java高级编程中的一些知识总结，其中第一章对Jdk 1.7.0_25中的多线程架构中的线程池ThreadPoolExecutor源码进行架构原理介绍以及源码解析。第二章则分析了几个违反Java高质量代码案例以及相应解决办法。如有总结的不好的地方，欢迎大家提出宝贵的意见和建议。">

    
    <link rel="alternative" href="https://github.com/search?q=pangjiuzala&type=Users" title="XingLiu&#39;s  Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="XingLiu&#39;s  Blog" title="XingLiu&#39;s  Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="XingLiu&#39;s  Blog">XingLiu&#39;s  Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">文章列表</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/01/Java线程池源码解析及高质量代码案例/" title="Java线程池源码解析及高质量代码案例" itemprop="url">Java线程池源码解析及高质量代码案例</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="XingLiu" target="_blank" itemprop="author">XingLiu</a>
		
  <p class="article-time">
    <time datetime="2015-11-01T03:12:46.000Z" itemprop="datePublished"> 发表于 2015-11-01</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java线程池架构原理及源码解析"><span class="toc-number">1.</span> <span class="toc-text">Java线程池架构原理及源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构建参数源码"><span class="toc-number">1.1.</span> <span class="toc-text">构建参数源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参数解释"><span class="toc-number">1.2.</span> <span class="toc-text">参数解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码详细解析"><span class="toc-number">1.3.</span> <span class="toc-text">源码详细解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#excute源码"><span class="toc-number">1.3.1.</span> <span class="toc-text">excute源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addIfUnderCorePoolSize源码"><span class="toc-number">1.3.2.</span> <span class="toc-text">addIfUnderCorePoolSize源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addThread源码"><span class="toc-number">1.3.3.</span> <span class="toc-text">addThread源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadFactory接口默认实现DefaultThreadFactory"><span class="toc-number">1.3.4.</span> <span class="toc-text">ThreadFactory接口默认实现DefaultThreadFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worker的run方法"><span class="toc-number">1.3.5.</span> <span class="toc-text">Worker的run方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getTask源码"><span class="toc-number">1.3.6.</span> <span class="toc-text">getTask源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execute方法部分实现"><span class="toc-number">1.3.7.</span> <span class="toc-text">execute方法部分实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ensureQueuedTaskHandled源码"><span class="toc-number">1.3.8.</span> <span class="toc-text">ensureQueuedTaskHandled源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reject源码"><span class="toc-number">1.3.9.</span> <span class="toc-text">reject源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#再次回到execute方法"><span class="toc-number">1.3.10.</span> <span class="toc-text">再次回到execute方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addIfUnderMaximumPoolSize源码"><span class="toc-number">1.3.11.</span> <span class="toc-text">addIfUnderMaximumPoolSize源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#workerDone源码"><span class="toc-number">1.3.12.</span> <span class="toc-text">workerDone源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runTask(task)源码"><span class="toc-number">1.3.13.</span> <span class="toc-text">runTask(task)源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加任务处理流程"><span class="toc-number">1.4.</span> <span class="toc-text">添加任务处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbortPolicy()"><span class="toc-number">1.4.1.</span> <span class="toc-text">AbortPolicy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CallerRunsPolicy()"><span class="toc-number">1.4.2.</span> <span class="toc-text">CallerRunsPolicy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiscardOldestPolicy()"><span class="toc-number">1.4.3.</span> <span class="toc-text">DiscardOldestPolicy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiscardPolicy()"><span class="toc-number">1.4.4.</span> <span class="toc-text">DiscardPolicy()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#违反Java高质量代码案例"><span class="toc-number">2.</span> <span class="toc-text">违反Java高质量代码案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#异步运算使用Callable接口"><span class="toc-number">2.1.</span> <span class="toc-text">异步运算使用Callable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先选择线程池"><span class="toc-number">2.2.</span> <span class="toc-text">优先选择线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程死锁"><span class="toc-number">2.3.</span> <span class="toc-text">线程死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#忽略设置阻塞队列长度"><span class="toc-number">2.4.</span> <span class="toc-text">忽略设置阻塞队列长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用stop方法停止线程"><span class="toc-number">2.5.</span> <span class="toc-text">使用stop方法停止线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#覆写start方法"><span class="toc-number">2.6.</span> <span class="toc-text">覆写start方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用过多线程优先级"><span class="toc-number">2.7.</span> <span class="toc-text">使用过多线程优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock与synchronized"><span class="toc-number">2.8.</span> <span class="toc-text">Lock与synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池异常处理"><span class="toc-number">2.9.</span> <span class="toc-text">线程池异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用SimpleThread类"><span class="toc-number">2.10.</span> <span class="toc-text">使用SimpleThread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程使用不当导致内存溢出"><span class="toc-number">2.11.</span> <span class="toc-text">线程使用不当导致内存溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作队列"><span class="toc-number">2.12.</span> <span class="toc-text">工作队列</span></a></li></ol></li></ol>
		
		</div>
		
		<p>本文为Java高级编程中的一些知识总结，其中第一章对Jdk 1.7.0_25中的多线程架构中的线程池ThreadPoolExecutor源码进行架构原理介绍以及源码解析。第二章则分析了几个违反Java高质量代码案例以及相应解决办法。如有总结的不好的地方，欢迎大家提出宝贵的意见和建议。<br><a id="more"></a></p>
<h1 id="Java线程池架构原理及源码解析">Java线程池架构原理及源码解析</h1><p>ThreadPoolExecutor是一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</p>
<h2 id="构建参数源码">构建参数源码</h2><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          RejectedExecutionHandler <span class="keyword">handler</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), <span class="keyword">handler</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数解释">参数解释</h2><ul>
<li><p><strong>corePoolSize</strong>：核心线程数，会一直存活，即使没有任务，线程池也会维护线程的最少数量。</p>
</li>
<li><p><strong>maximumPoolSize</strong>： 线程池维护线程的最大数量。</p>
</li>
<li><p><strong>keepAliveTime</strong>： 线程池维护线程所允许的空闲时间，当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。如果allowCoreThreadTimeout设置为<br>true，则所有线程均会退出直到线程数量为0。<br>unit： 线程池维护线程所允许的空闲时间的单位、可选参数值为：TimeUnit中的几个静态属性：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。</p>
</li>
<li><p><strong>workQueue</strong>：线程池所使用的缓冲队列，常用的是：java.util.concurrent.ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue。</p>
</li>
<li><p><strong>handler</strong>： 线程池中的数量大于maximumPoolSize，对拒绝任务的处理策略，默认值ThreadPoolExecutor.AbortPolicy()。</p>
</li>
</ul>
<h2 id="源码详细解析">源码详细解析</h2><h3 id="excute源码">excute源码</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个任务通过 execute(Runnable)方法被添加到线程池，任务就是一个Runnable类型的对象，任务的执行方法就是run()方法，如果传入的为null，侧抛出NullPointerException。<br>首先第一个判定空操作就不用说了，下面判定的poolSize &gt;= corePoolSize成立时候会进入if的区域，当然它不成立也有可能会进入，他会判定addIfUnderCorePoolSize是否返回false，如果返回false就会进去。<br>如果当前线程数小于corePoolSize，调用addIfUnderCorePoolSize方法，addIfUnderCorePoolSize方法首先调用mainLock加锁，再次判断当前线程数小于corePoolSize并且线程池处于RUNNING状态，则调用addThread增加线程。</p>
<center><br><img src="http://7xiur2.com1.z0.glb.clouddn.com/0376.png" alt=""><br>图一：ThreadPoolExecutor运行状态图<br></center>

<h3 id="addIfUnderCorePoolSize源码">addIfUnderCorePoolSize源码</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addThread方法首先创建Work对象，然后调用threadFactory创建新的线程，如果创建的线程不为null，将Work对象的 thread属性设置为此创建出来的线程，并将此Work对象放入workers中，然后在增加当前线程池的中线程数，增加后回到 addIfUnderCorePoolSize方法 ，释放mainLock，最后启动这个新创建的线程来执行新传入的任务。<br>可以发现，这段源码是如果发现小于corePoolSize就会创建一个新的线程，并且调用线程的start()方法将线程运行起来:这个addThread()方法，我们先不考虑细节，因为我们还要先看到前面是怎么进去的，这里可以发信啊，只有没有创建成功Thread才会返回false，也就是当当前的poolSize &gt; corePoolSize的时候，或线程池已经不是在running状态的时候才会出现。<br>注意：这里在外部判定一次poolSize和corePoolSize只是初步判定，内部是加锁后判定的，以得到更为准确的结果，而外部初步判定如果是大于了，就没有必要进入这段有锁的代码了。</p>
<h3 id="addThread源码">addThread源码</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">Thread</span> addThread(Runnable firstTask)</span><br><span class="line">&#123;</span><br><span class="line">    Worker w = <span class="literal">new</span> Worker(firstTask);</span><br><span class="line">    <span class="keyword">Thread</span> t = threadFactory<span class="built_in">.</span>newThread(w);</span><br><span class="line">    &lt; span style = <span class="string">"color:#ff0000;"</span> &gt; &lt; / span &gt;</span><br><span class="line">                   <span class="keyword">if</span> (t != <span class="built_in">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        w<span class="built_in">.</span><span class="keyword">thread</span> = t;</span><br><span class="line">        workers<span class="built_in">.</span>add(w);</span><br><span class="line">        int nt = ++poolSize;</span><br><span class="line">        <span class="keyword">if</span> (nt &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = nt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadFactory接口默认实现DefaultThreadFactory">ThreadFactory接口默认实现DefaultThreadFactory</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Thread</span> newThread(Runnable r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">Thread</span> t = <span class="literal">new</span> <span class="keyword">Thread</span>(<span class="keyword">group</span>, r,</span><br><span class="line">                          namePrefix + threadNumber<span class="built_in">.</span>getAndIncrement(),</span><br><span class="line">                          <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t<span class="built_in">.</span>isDaemon())</span><br><span class="line">        t<span class="built_in">.</span>setDaemon(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t<span class="built_in">.</span>getPriority() != <span class="keyword">Thread</span><span class="built_in">.</span>NORM_PRIORITY)</span><br><span class="line">        t<span class="built_in">.</span>setPriority(<span class="keyword">Thread</span><span class="built_in">.</span>NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个Work，其余的操作，就是讲poolSize叠加，然后将将其放入workers的运行队列等操作；<br>我们主要关心Worker是干什么的，因为这个threadFactory对我们用途不大，只是做了Thread的命名处理；而Worker你会发现它的定义也是一个Runnable，外部开始在代码段中发现了调用哪个这个Worker的start()方法，也就是线程的启动方法，其实也就是调用了Worker的run()方法，那么我们重点要关心run方法是如何处理的。</p>
<h3 id="Worker的run方法">Worker的run方法</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Runnable <span class="keyword">task</span> = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            runTask(<span class="keyword">task</span>);</span><br><span class="line">            <span class="keyword">task</span> = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上方法可以看出，Worker所在的线程启动后，首先执行创建其时传入的Runnable任务，执行完成后，循环调用getTask来获取新的任务，在没有任务的情况下，退出此线程。FirstTask其实就是开始在创建work的时候，由外部传入的Runnable对象，也就是你自己的Thread，你会发现它如果发现task为空，就会调用getTask()方法再判定，直到两者为空，并且是一个while循环体。</p>
<h3 id="getTask源码">getTask源码</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">getTask</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> state = runState;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; SHUTDOWN)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Runnable r;</span><br><span class="line">            <span class="keyword">if</span> (state == SHUTDOWN)  <span class="comment">// Help drain queue</span></span><br><span class="line">                r = workQueue.poll();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (poolSize &gt; corePoolSize || allowCoreThreadTimeOut)</span><br><span class="line">                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">if</span> (workerCanExit())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (runState &gt;= SHUTDOWN) <span class="comment">// Wake up others</span></span><br><span class="line">                    interruptIdleWorkers();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Else retry</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException ie)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// On interruption, re-check runState</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现它是从workQueue队列中，也就是等待队列中获取一个元素出来并返回！当前线程运行完后，在到workQueue中去获取一个task出来，继续运行，这样就保证了线程池中有一定的线程一直在运行；此时若跳出了while循 环，只有workQueue队列为空才会出现或出现了类似于shutdown的操作，自然运行队列会减少1，当再有新的线程进来的时候，就又开始向 worker里面放数据了，这样以此类推，实现了线程池的功能。</p>
<h3 id="execute方法部分实现">execute方法部分实现</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(<span class="command"><span class="keyword">command</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">        ensureQueuedTaskHandled(<span class="command"><span class="keyword">command</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(<span class="command"><span class="keyword">command</span>))</span></span><br><span class="line">    reject(<span class="command"><span class="keyword">command</span>); // <span class="title">is</span> <span class="title">shutdown</span> <span class="title">or</span> <span class="title">saturated</span></span></span><br></pre></td></tr></table></figure>
<pre><code>如果当前线程池数量大于corePoolSize或<span class="keyword">addIfUnderCorePoolSize方法执行失败，则执行后续操作；如果线程池处于运行状态 </span>并且workQueue中成功加入任务，再次判断如果线程池的状态不为运行状态或当前线程池数为<span class="number">0</span>，则调用 ensureQueuedTaskHandled方法。
</code></pre><h3 id="ensureQueuedTaskHandled源码">ensureQueuedTaskHandled源码</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">ensureQueuedTaskHandled</span><span class="params">(Runnable command)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> state = runState;</span><br><span class="line">        <span class="keyword">if</span> (state != RUNNING &amp;&amp; workQueue.remove(command))</span><br><span class="line">            reject = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state &lt; STOP &amp;&amp;</span><br><span class="line">                 poolSize &lt; Math.max(corePoolSize, <span class="number">1</span>) &amp;&amp;</span><br><span class="line">                 !workQueue.isEmpty())</span><br><span class="line">            t = addThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reject)</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">        t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个if，也就是当当前状态为running的时候，就会去执行workQueue.offer(command)，这个workQueue其实就是一 个BlockingQueue，offer()操作就是在队列的尾部写入一个对象，此时写入的对象为线程的对象而已；所以你可以认为只有线程池在 RUNNING状态，才会在队列尾部插入数据，否则就执行else if，其实else if可以看出是要做一个是否大于MaximumPoolSize的判定，如果大于这个值，就会做reject的操作。ensureQueuedTaskHandled方法判断线程池运行，如果状态不为运行状态，从workQueue中删除，并调用reject做拒绝处理。</p>
<h3 id="reject源码">reject源码</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">handler</span>.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="再次回到execute方法">再次回到execute方法</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(<span class="command"><span class="keyword">command</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">        ensureQueuedTaskHandled(<span class="command"><span class="keyword">command</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(<span class="command"><span class="keyword">command</span>))</span></span><br><span class="line">    reject(<span class="command"><span class="keyword">command</span>); // <span class="title">is</span> <span class="title">shutdown</span> <span class="title">or</span> <span class="title">saturated</span></span></span><br></pre></td></tr></table></figure>
<p>如线程池workQueue offer失败或不处于运行状态，调用addIfUnderMaximumPoolSize, addIfUnderMaximumPoolSize方法基本和addIfUnderCorePoolSize实现类似，不同点在于根据最大线程数（maximumPoolSize）进行比较，如果超过最大线程数，返回false，调用reject方法。</p>
<h3 id="addIfUnderMaximumPoolSize源码">addIfUnderMaximumPoolSize源码</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">addIfUnderMaximumPoolSize</span><span class="params">(Runnable firstTask)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是如果线程池满了，而且线程池调用了shutdown后，还在调用execute方法时，就会抛出上面说明的异常：RejectedExecutionException。</p>
<h3 id="workerDone源码">workerDone源码</h3><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workerDone</span><span class="params">(Worker w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">        <span class="keyword">if</span> (--poolSize == <span class="number">0</span>)</span><br><span class="line">            tryTerminate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里将workers.remove(w)掉，并且调用了<code>—poolSize</code>来做操作。至于tryTerminate是做了更多关于回收方面的操作。</p>
<h3 id="runTask(task)源码">runTask(task)源码</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> runTask(Runnable <span class="keyword">task</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock runLock = <span class="keyword">this</span>.runLock;</span><br><span class="line">    runLock.lock();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (runState &lt; STOP &amp;&amp;</span><br><span class="line">                Thread.interrupted() &amp;&amp;</span><br><span class="line">                runState &gt;= STOP)</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">        beforeExecute(thread, <span class="keyword">task</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">task</span>.run();</span><br><span class="line">            ran = <span class="keyword">true</span>;</span><br><span class="line">            afterExecute(<span class="keyword">task</span>, <span class="keyword">null</span>);</span><br><span class="line">            ++completedTasks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ran)</span><br><span class="line">                afterExecute(<span class="keyword">task</span>, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        runLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到，这里面的task为传入的task信息，调用的不是start方法，而是run方法，因为run方法直接调用不会启动新的线程，也是因为这样，导致了你无法获取到你自己的线程的状态，因为线程池是直接调用的run方法，而不是start方法来运行。<br>这里有个beforeExecute和afterExecute方法，分别代表在执行前和执行后，你可以做一段操作，在这个类中，这两个方法都是空的，因为普通线程池无需做更多的操作。<br>如果你要实现类似暂停等待通知的或其他的操作，可以自己extends后进行重写构造。</p>
<h2 id="添加任务处理流程">添加任务处理流程</h2><h3 id="AbortPolicy()">AbortPolicy()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Always throws RejectedExecutionException.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span><br><span class="line">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span><br><span class="line">     * <span class="doctag">@throws</span> RejectedExecutionException always.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*当线程池中的数量等于最大线程数时,直接抛出抛出java.util.concurrent.RejectedExecutionException异常。*/</span></span><br></pre></td></tr></table></figure>
<h3 id="CallerRunsPolicy()">CallerRunsPolicy()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Executes task r in the caller's thread, unless the executor</span><br><span class="line">     * has been shut down, in which case the task is discarded.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span><br><span class="line">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown())</span><br><span class="line">        &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程池中的数量等于最大线程数时、重试执行当前的任务，交由调用者线程来执行任务。</p>
<h3 id="DiscardOldestPolicy()">DiscardOldestPolicy()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Obtains and ignores the next task that the executor</span><br><span class="line">     * would otherwise execute, if one is immediately available,</span><br><span class="line">     * and then retries execution of task r, unless the executor</span><br><span class="line">     * is shut down, in which case task r is instead discarded.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span><br><span class="line">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown())</span><br><span class="line">        &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程池中的数量等于最大线程数时、抛弃线程池中最后一个要执行的任务，并执行新传入的任务。</p>
<h3 id="DiscardPolicy()">DiscardPolicy()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Does nothing, which has the effect of discarding task r.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span><br><span class="line">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程池中的数量等于最大线程数时，不做任何动作。<br>通常你得到线程池后，会调用其中的：submit方法或execute方法去操作；其实你会发现，submit方法最终会调用execute方法来进行操 作，只是他提供了一个Future来托管返回值的处理而已，当你调用需要有返回值的信息时，你用它来处理是比较好的；这个Future会包装对 Callable信息，并定义一个Sync对象，当你发生读取返回值的操作的时候，会通过Sync对象进入锁，直到有返回值的数据通知。</p>
<h1 id="违反Java高质量代码案例">违反Java高质量代码案例</h1><h2 id="异步运算使用Callable接口">异步运算使用Callable接口</h2><p>Callable接口代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">v <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现Callable接口，只是表明它是一个可调用的任务，并不表示它具有多线程运算的能力，还是要执行器来执行。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxCalculator</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seedMoney;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaxCalculator</span><span class="params">(<span class="keyword">int</span> _seedMoney)</span></span>&#123;</span><br><span class="line">        seedMoney=_seedMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       TimeUnit.MILLISECONDS.sleep(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> seedMoney/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里模拟税款计算器运算，可能花费10秒钟时间。用户输入即有输出，若耗时较长，则显示运算进度。如果我们直接计算，就只有一个main线程，是不可能友好提示的，如果税金不计算完毕，也不会执行后续动作，所以最好的办法就是重启一个线程来运算，让main线程做进度提示</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ExecutorService es=Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;Integer&gt; future=es.submit(<span class="keyword">new</span> TaxCalculator(<span class="number">100</span>));</span><br><span class="line">        <span class="keyword">while</span>(!future.isDone())&#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"#"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"\n 计算完成，税金是："</span>+future.<span class="built_in">get</span>()+<span class="string">"元"</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Executors是一个静态工具类，提供了异步执行器的创建能力，如单线程执行newSingleThreadExcutor、固定线程数量的执行器newFixedThreadPool等，一般是异步计算的入口类。</p>
<h2 id="优先选择线程池">优先选择线程池</h2><p>线程的状态只能由新建状态转变为运行态后才可能被阻塞或等待，最后终结，不可能产生本末倒置的情况，代码如下:<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    </span><br><span class="line">    Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程在运行"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">while</span>(!t.getState().equals(Thread.State.TERMINATED))&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时程序运行会报IllegalThreadStateException异常，原因就是不能从结束状态直接转换为可运行状态。这时可以引入线程池，当系统需要时直接从线程池中获得线程，运算出结果，再把线程返回到线程池中，代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                @<span class="function">Override</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程死锁">线程死锁</h2><p>Java是单线程语言，一旦线程死锁，只能借助外部进程重启应用才能解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name + <span class="string">"进入A.a1()"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + <span class="string">"试图访问B.b2()"</span>);</span><br><span class="line">            b.b2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"进入 a.a2()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b1</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name + <span class="string">"进入B.b1()"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + <span class="string">"试图访问A.a2()"</span>);</span><br><span class="line">            a.a2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"进入 B.b2()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">final</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                a.a1(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程A"</span>).start();</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                b.b1(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程B"</span>).start();</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此段程序定义了两个资源A和B，然后在两个线程A、B中使用了该资源，由于两个资源之间有交互操作，并且都是同步方法，因此在线程A休眠1秒钟后，它会试图访问资源B的b2方法，但是线程B持有该类的锁，并同时在等待A线程释放其锁资源，所以此时就出现了两个线程在互相等待释放资源的情况，也就是死锁。可以使用自旋锁改进，代码如下:  </p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">b2</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Lock.trylock(<span class="number">2</span>, TimeUnit.SECONDS))</span><br><span class="line">        &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"进入 B.b2()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        Lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它原理和互斥锁一样，如果一个执行单元要想访问被自旋锁保护的共享资源，则必须先得到锁，在访问完共享资源后，也必须释放锁。</p>
<h2 id="忽略设置阻塞队列长度">忽略设置阻塞队列长度</h2><p>BlockingQueue是一种集合，实现了Collection接口，容量是不可以自行管理的，代码如下：<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        BlockingDeque&lt;<span class="keyword">String</span>&gt; bq = (BlockingDeque&lt;<span class="keyword">String</span>&gt;) <span class="keyword">new</span> ArrayBlockingQueue&lt;<span class="keyword">String</span>&gt;(</span><br><span class="line">                <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            bq.<span class="built_in">add</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>阻塞队列容量是固定的，非阻塞队列则是变长的。阻塞队列可以在声明是指定队列的容量，若指定的容量，则元素的数量不可超过该容量，若不指定，队列的容量为Integer的最大值</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span></span><br><span class="line">    <span class="title">BlockingDeque</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> E[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> add(E e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (offer(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> offer(E e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">count</span> == items.length)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                insert(e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面在加入元素时，如果判断当前队列已满，则返回false，表示插入失败，之后再包装成队列满异常。</p>
<h2 id="使用stop方法停止线程">使用stop方法停止线程</h2><p>stop方法会破坏原子逻辑，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutiThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">""</span>) &#123;</span><br><span class="line">            a++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            a--;</span><br><span class="line">            String tn = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(tn + <span class="string">":a="</span> + a);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MutiThread t = <span class="keyword">new</span> MutiThread();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(t).start();</span><br><span class="line">        &#125;</span><br><span class="line">        t1.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有线程共享了一个MutilThread的实例变量t，由于在run方法中加入了同步代码块，所以只能有一个线程进入到synchronized块中，可以自定义标志位来决定线程执行情况，代码如下:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeStopThread</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Thread</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span> volatile boolean stop=<span class="literal">false</span>;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public void run()</span><br><span class="line">    &#123;<span class="comment">//判断线程体是否运行</span></span><br><span class="line">        <span class="keyword">while</span>(stop)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程终止</span></span><br><span class="line">    public void terminate()&#123;</span><br><span class="line">        stop=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在线程体中判断是否需要停止运行，即可保证线程体的逻辑完整性，而且也不会破坏原子逻辑。</p>
<h2 id="覆写start方法">覆写start方法</h2><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutiThread</span> <span class="keyword">implements</span> <span class="title">Thread</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用线程体</span></span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    MutiThread t = <span class="keyword">new</span> MutiThread();</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main方法根本就没有启动一个子线程，整个应用程序中只有一个主线程在运行，并不会创建其他的线程。改进后代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutiThread</span> <span class="keyword">implements</span> <span class="title">Thread</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">/*线程启动前的业务处理*/</span></span><br><span class="line">        <span class="keyword">super</span>.start();</span><br><span class="line">        <span class="comment">/*线程启动后的业务处理*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>start方法调用父类的start方法，没有主动调用run方法，由JVM自行调用，不用我们的显式实现。</p>
<h2 id="使用过多线程优先级">使用过多线程优先级</h2><p>Java线程有10个基本，级别为0代表JVM<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MutiThread implements Runnable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> _priority)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">        t.setPriority(_priority);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            Math.hypot(Math.<span class="built_in">pow</span>(<span class="number">924526789</span>, i), Math.<span class="built_in">cos</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Priority:"</span>+Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> MutiThread().start(i%<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java优先级只是代表抢占CPU机会大小，优先级越高，抢占CPU机会越大，被优先执行的可能性越高，优先级相差不大，则抢占CPU机会差别也不大。导致优先级为9的线程比优先级为10的线程先运行。于是在Thread类中设置三个优先级，建议使用优先级常量，而不是1到10的随机数字，代码如下:</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">  * The default priority that is assigned to a thread.</span><br><span class="line">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * The maximum priority that a thread can have.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns a reference to the currently executing thread object.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span>  the currently executing thread.</span><br><span class="line"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lock与synchronized">Lock与synchronized</h2><p>Lock为显式锁，synchronized为内部锁，代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Task</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    public void dosomething()&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Thread</span>.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuffer</span> sb=<span class="keyword">new</span> <span class="type">StringBuffer</span>();</span><br><span class="line">        sb.append(<span class="string">"线程名:"</span>+<span class="type">Thread</span>.currentThread().getName());</span><br><span class="line">        sb.append(<span class="string">",线程时间:"</span>+<span class="type">Calendar</span>.getInstance().get(<span class="number">13</span>)+<span class="string">"s"</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示锁任务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithLock</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Task</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> lock=<span class="keyword">new</span> <span class="type">ReentrantLock</span>();</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            dosomething();</span><br><span class="line">        &#125; <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="comment">//內部锁任务</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TaskWithSync</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Task</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        public void run() &#123;</span><br><span class="line">        </span><br><span class="line">                synchronized (<span class="string">"A"</span>) &#123;</span><br><span class="line">                    dosomething();</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>对于同步资源来说，显式锁时对象级别的锁，而内部锁时类级别的锁，也就是说lock锁时跟随对象的，synchronized锁时跟随类<br>改进方法：把Lock定义为所有线程的共享变量。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多个线程共享锁</span></span><br><span class="line">        <span class="keyword">final</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池异常处理">线程池异常处理</h2><p>Java中线程执行的任务接口java.lang.Runnable 要求不抛出Checked异常，</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Runnable</span> &#123;   </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果 run() 方法中抛出了RuntimeException，将会怎么处理了？<br>通常java.lang.Thread对象运行设置一个默认的异常处理方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">java<span class="class">.lang</span><span class="class">.Thread</span><span class="class">.setDefaultUncaughtExceptionHandler</span>(UncaughtExceptionHandler)</span><br></pre></td></tr></table></figure>
<p>而这个默认的静态全局的异常捕获方法时输出堆栈。当然，我们可以覆盖此默认实现，只需要一个自定义的<code>java.lang.Thread.UncaughtExceptionHandler</code>接口实现即可。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> &#123;   </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span>(<span class="params">Thread t, Throwable e</span>)</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在线程池中却比较特殊。默认情况下，线程池 java.util.concurrent.ThreadPoolExecutor 会Catch住所有异常， 当任务执行完成(java.util.concurrent.ExecutorService.submit(Callable))获取其结果 时(java.util.concurrent.Future.get())会抛出此RuntimeException。</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">/**   </span><br><span class="line"> * <span class="type">Waits</span> <span class="keyword">if</span> necessary <span class="keyword">for</span> the computation to complete, <span class="keyword">and</span> then   </span><br><span class="line"> * retrieves its <span class="literal">result</span>.   </span><br><span class="line"> *   </span><br><span class="line"> * @<span class="keyword">return</span> the computed <span class="literal">result</span>   </span><br><span class="line"> * @throws <span class="type">CancellationException</span> <span class="keyword">if</span> the computation was cancelled   </span><br><span class="line"> * @throws <span class="type">ExecutionException</span> <span class="keyword">if</span> the computation threw an exception   </span><br><span class="line"> * @throws <span class="type">InterruptedException</span> <span class="keyword">if</span> the current thread was interrupted <span class="keyword">while</span> waiting   </span><br><span class="line"> */   </span><br><span class="line">V get() throws <span class="type">InterruptedException</span>, <span class="type">ExecutionException</span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>ExecutionException</code> 异常即是<code>java.lang.Runnable</code> 或者 <code>java.util.concurrent.Callable</code> 抛出的异常。</p>
<p>也就是说，线程池在执行任务时捕获了所有异常，并将此异常加入结果中。这样一来线程池中的所有线程都将无法捕获到抛出的异常。 从而无法通过设置线程的默认捕获方法拦截的错误异常。也不同通过 自定义线程来完成异常的拦截。好在java.util.concurrent.ThreadPoolExecutor 预留了一个方法，运行在任务执行完毕进行扩展（当然也预留一个protected方法beforeExecute(Thread t, Runnable r)）：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>此方法的默认实现为空，这样我们就可以通过继承或者覆盖ThreadPoolExecutor 来达到自定义的错误处理。</p>
<p>解决办法如下：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">11</span>, <span class="number">100</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="comment">//   </span></span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10000</span>),<span class="comment">//   </span></span><br><span class="line">        <span class="keyword">new</span> DefaultThreadFactory()) &#123;   </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">super</span>.afterExecute(r, t);   </span><br><span class="line">        printException(r, t);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;   </span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">printException</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span> &amp;&amp; r <span class="keyword">instanceof</span> Future&lt;?&gt;) &#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            Future&lt;?&gt; future = (Future&lt;?&gt;) r;   </span><br><span class="line">            <span class="keyword">if</span> (future.isDone())   </span><br><span class="line">                future.get();   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancellationException ce) &#123;   </span><br><span class="line">            t = ce;   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException ee) &#123;   </span><br><span class="line">            t = ee.getCause();   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;   </span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// ignore/reset   </span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>)   </span><br><span class="line">        log.<span class="keyword">error</span>(t.getMessage(), t);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用SimpleThread类">使用SimpleThread类</h2><p>TestThreadPool类是一个测试程序，用来模拟客户端的请求，当你运行它时，系统首先会显示线程池的初始化信息，然后提示你从键盘上输入字符串，并按下回车键，这时你会发现屏幕上显示信息，告诉你某个线程正在处理你的请求，如果你快速地输入一行行字符串，那么你会发现线程池中不断有线程被唤醒，来处理你的请求，在本例中，我创建了一个拥有10个线程的线程池，如果线程池中没有可用线程了，系统会提示你相应的警告信息，但如果你稍等片刻，那你会发现屏幕上会陆陆续续提示有线程进入了睡眠状态，这时你又可以发送新的请求了。<br>代码如下：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TestThreadPool.java</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.io.*;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>));</span><br><span class="line">            String s;</span><br><span class="line">            ThreadPoolManager manager = <span class="keyword">new</span> ThreadPoolManager(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">while</span>((s = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                manager.process(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(IOException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadPoolManager类，顾名思义，它是一个用于管理线程池的类，它的主要职责是初始化线程池，并为客户端的请求分配不同的线程来进行处理，如果线程池满了，它会对你发出警告信息。<br>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">　　</span><br><span class="line">　　<span class="keyword">class</span> ThreadPoolManager</span><br><span class="line">    　</span><br><span class="line">&#123;</span><br><span class="line">    　</span><br><span class="line">    　　 <span class="keyword">private</span> <span class="keyword">int</span> maxThread;</span><br><span class="line">    　　 <span class="keyword">public</span> Vector <span class="built_in">vector</span>;</span><br><span class="line">    　　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxThread</span><span class="params">(<span class="keyword">int</span> threadCount)</span></span><br><span class="line">    　　</span><br><span class="line">    </span>&#123;</span><br><span class="line">        　　 maxThread = threadCount;</span><br><span class="line">        　　</span><br><span class="line">    &#125;</span><br><span class="line">    　　</span><br><span class="line">    　　 <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolManager</span><span class="params">(<span class="keyword">int</span> threadCount)</span></span><br><span class="line">    　　</span><br><span class="line">    </span>&#123;</span><br><span class="line">        　　 setMaxThread(threadCount);</span><br><span class="line">        　　System.out.println(<span class="string">"Starting thread pool..."</span>);</span><br><span class="line">        　　 <span class="built_in">vector</span> = <span class="keyword">new</span> Vector();</span><br><span class="line">        　　 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">            　　 &#123;</span><br><span class="line">            　　 SimpleThread thread = <span class="keyword">new</span> SimpleThread(i);</span><br><span class="line">            　　 <span class="built_in">vector</span>.addElement(thread);</span><br><span class="line">            　　 thread.start();</span><br><span class="line">            　　</span><br><span class="line">        &#125;</span><br><span class="line">        　　</span><br><span class="line">    &#125;</span><br><span class="line">    　　</span><br><span class="line">    　　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String argument)</span></span><br><span class="line">    　　</span><br><span class="line">    </span>&#123;</span><br><span class="line">        　　 <span class="keyword">int</span> i;</span><br><span class="line">        　　 <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">vector</span>.size(); i++)</span><br><span class="line">            　 &#123;</span><br><span class="line">            　 SimpleThread currentThread = (SimpleThread)<span class="built_in">vector</span>.elementAt(i);</span><br><span class="line">            　　 <span class="keyword">if</span>(!currentThread.isRunning())</span><br><span class="line">                　　 &#123;</span><br><span class="line">                　 System.out.println(<span class="string">"Thread "</span> + (i + <span class="number">1</span>) + <span class="string">" is processing:"</span> +</span><br><span class="line">                　　argument);</span><br><span class="line">                　currentThread.setArgument(argument);</span><br><span class="line">                　　 currentThread.setRunning(<span class="literal">true</span>);</span><br><span class="line">                　　 <span class="keyword">return</span>;</span><br><span class="line">                　</span><br><span class="line">            &#125;</span><br><span class="line">            　　</span><br><span class="line">        &#125;</span><br><span class="line">        　　<span class="keyword">if</span>(i == <span class="built_in">vector</span>.size())</span><br><span class="line">            　　 &#123;</span><br><span class="line">            　　 System.out.println(<span class="string">"pool is full, try in another time."</span>);</span><br><span class="line">            　　</span><br><span class="line">        &#125;</span><br><span class="line">        　　</span><br><span class="line">    &#125;</span><br><span class="line">    　　</span><br><span class="line">&#125;<span class="comment">//end of class ThreadPoolManager</span></span><br></pre></td></tr></table></figure>
<p>我们先关注一下这个类的构造函数，然后再看它的process()方法。第16－24行是它的构造函数，首先它给ThreadPoolManager类的成员变量maxThread赋值，maxThread表示用于控制线程池中最大线程的数量。第18行初始化一个数组vector，它用来存放所有的SimpleThread类，这时候就充分体现了JAVA语言的优越性与艺术性：如果你用C语言的话，至少要写100行以上的代码来完成vector的功能，而且C语言数组只能容纳类型统一的基本数据类型，无法容纳对象。好了，闲话少说，第19－24行的循环完成这样一个功能：先创建一个新的SimpleThread类，然后将它放入vector中去，最后用thread.start()来启动这个线程，为什么要用start()方法来启动线程呢？因为这是JAVA语言中所规定的，如果你不用的话，那这些线程将永远得不到激活，从而导致本示例程序根本无法运行。</p>
<p>process()方法，第30－40行的循环依次从vector数组中选取SimpleThread线程，并检查它是否处于激活状态（所谓激活状态是指此线程是否正在处理客户端的请求），如果处于激活状态的话，那继续查找vector数组的下一项，如果vector数组中所有的线程都处于激活状态的话，那它会打印出一条信息，提示用户稍候再试。相反如果找到了一个睡眠线程的话，那第35－38行会对此进行处理，它先告诉客户端是哪一个线程来处理这个请求，然后将客户端的请求，即字符串argument转发给SimpleThread类的setArgument()方法进行处理，并调用SimpleThread类的setRunning()方法来唤醒当前线程，来对客户端请求进行处理。</p>
<p>解决办法是引入SimpleThread类，它是Thread类的一个子类，它才真正对客户端的请求进行处理，SimpleThread在示例程序初始化时都处于睡眠状态，但如果它接受到了ThreadPoolManager类发过来的调度信息，则会将自己唤醒，并对请求进行处理。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span><br><span class="line">    　</span><br><span class="line"></span>&#123;</span><br><span class="line">    　　 <span class="keyword">private</span> <span class="keyword">boolean</span> runningFlag;</span><br><span class="line">    　　 <span class="keyword">private</span> String argument;</span><br><span class="line">    　　 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span><br><span class="line">    　　</span><br><span class="line">    </span>&#123;</span><br><span class="line">        　　 <span class="keyword">return</span> runningFlag;</span><br><span class="line">        　　</span><br><span class="line">    &#125;</span><br><span class="line">    　　<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRunning</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span><br><span class="line">    　　</span><br><span class="line">    </span>&#123;</span><br><span class="line">        　　 runningFlag = flag;</span><br><span class="line">        　　 <span class="keyword">if</span>(flag)</span><br><span class="line">            　　 <span class="keyword">this</span>.notify();</span><br><span class="line">        　　</span><br><span class="line">    &#125;</span><br><span class="line">    　　</span><br><span class="line">    　　 <span class="function"><span class="keyword">public</span> String <span class="title">getArgument</span><span class="params">()</span></span><br><span class="line">    　　</span><br><span class="line">    </span>&#123;</span><br><span class="line">        　　 <span class="keyword">return</span> <span class="keyword">this</span>.argument;</span><br><span class="line">        　　</span><br><span class="line">    &#125;</span><br><span class="line">    　　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArgument</span><span class="params">(String string)</span></span><br><span class="line">    　　</span><br><span class="line">    </span>&#123;</span><br><span class="line">        　　 argument = string;</span><br><span class="line">        　　</span><br><span class="line">    &#125;</span><br><span class="line">    　　</span><br><span class="line">    　　 <span class="function"><span class="keyword">public</span> <span class="title">SimpleThread</span><span class="params">(<span class="keyword">int</span> threadNumber)</span></span><br><span class="line">    　　</span><br><span class="line">    </span>&#123;</span><br><span class="line">        　　 runningFlag = <span class="keyword">false</span>;</span><br><span class="line">        　　 System.out.println(<span class="string">"thread "</span> + threadNumber + <span class="string">"started."</span>);</span><br><span class="line">        　　</span><br><span class="line">    &#125;</span><br><span class="line">    　　</span><br><span class="line">    　　 <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span><br><span class="line">    　　</span><br><span class="line">    </span>&#123;</span><br><span class="line">        　　 <span class="keyword">try</span>&#123;</span><br><span class="line">            　　 <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                　　 &#123;</span><br><span class="line">                　　 <span class="keyword">if</span>(!runningFlag)</span><br><span class="line">                    　　 &#123;</span><br><span class="line">                    　　 <span class="keyword">this</span>.wait();</span><br><span class="line">                    　　</span><br><span class="line">                &#125;</span><br><span class="line">                　　 <span class="keyword">else</span></span><br><span class="line">                    　　 &#123;</span><br><span class="line">                    　　 System.out.println(<span class="string">"processing "</span> + getArgument() + <span class="string">"... done."</span>);</span><br><span class="line">                    　　 sleep(<span class="number">5000</span>);</span><br><span class="line">                    　　 System.out.println(<span class="string">"Thread is sleeping..."</span>);</span><br><span class="line">                    　　 setRunning(<span class="keyword">false</span>);</span><br><span class="line">                    　　</span><br><span class="line">                &#125;</span><br><span class="line">                　　</span><br><span class="line">            &#125;</span><br><span class="line">            　　</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            　　 System.out.println(<span class="string">"Interrupt"</span>);</span><br><span class="line">            　　</span><br><span class="line">        &#125;</span><br><span class="line">        　　</span><br><span class="line">    &#125;<span class="comment">//end of run()</span></span><br><span class="line"></span><br><span class="line">    　　</span><br><span class="line">&#125;<span class="comment">//end of class SimpleThread</span></span><br></pre></td></tr></table></figure>
<h2 id="线程使用不当导致内存溢出">线程使用不当导致内存溢出</h2><p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; t;</span><br><span class="line">    <span class="annotation">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> object <span class="title">call</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序是这样的，有一个线程会往List中插入对象，线程池中的多个线程丛List中取数据，然后进行处理，处理完以后把对象从List中删除。outofmemory有几种可能：</p>
<p>1.线程池中的处理线程在处理完以后没有从List中删掉元素</p>
<p>2.向List中插入元素的速度高于从List中删除元素的速度，造成List中积累的元素数量不断攀升，可以随时打印一下List中的元素数量，看是否是一支攀升。</p>
<p>3.ArrayList和LinkedList都不是线程安全的，把List换成Vector或者保证List变量通过Synchronized同步访问。</p>
<p>4.在程序的其他地方还持有List中的对象句柄，虽然从List中删掉了，如果别的地方还保存着该对象的句柄，那么也不会被垃圾回收。</p>
<p>5.JVM的应用程序最大可用内存参数（-Xmx）配置过低</p>
<p>如：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">JAV<span class="built_in">A_OPTS</span>=<span class="string">"-server -Xms800m -Xmx800m -XX:PermSize=64M -XX:MaxNewSize=256m -XX:MaxPermSize=128m -Djava.awt.headless=true "</span></span><br></pre></td></tr></table></figure>
<h2 id="工作队列">工作队列</h2><p>是同一组固定的工作线程相结合的工作队列，它使用 wait() 和 notify() 来通知等待线程新的工作已经到达了。该工作队列通常被实现成具有相关监视器对象的某种链表，下边的代码显示了简单的合用工作队列的示例。尽管 Thread API 没有对使用 Runnable 接口强加特殊要求，但使用 Runnable 对象队列的这种模式是调度程序和工作队列的公共约定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> WorkQueue</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">int</span> nThreads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final PoolWorker[] threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final LinkedList <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkQueue</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.nThreads = nThreads;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        threads = <span class="keyword">new</span> PoolWorker[nThreads];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i</span><br><span class="line"></span><br><span class="line">                threads[i] = <span class="keyword">new</span> PoolWorker();</span><br><span class="line"></span><br><span class="line">                threads[i].start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    synchronized(<span class="built_in">queue</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>.addLast(r);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>.notify();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> PoolWorker extends Thread</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            synchronized(<span class="built_in">queue</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">queue</span>.isEmpty())</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">queue</span>.wait();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException ignored)</span><br><span class="line"></span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                r = (Runnable) <span class="built_in">queue</span>.removeFirst();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we don't catch RuntimeException,</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// the pool could leak threads</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                r.run();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException e)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// You might want to log something here</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现使用的是 notify() 而不是 notifyAll() 。大多数专家建议使用 notifyAll() 而不是 notify() ，而且理由很充分：使用 notify() 具有难以捉摸的风险，只有在某些特定条件下使用该方法才是合适的。另一方面，如果使用得当， notify() 具有比 notifyAll() 更可取的性能特征；特别是，notify() 引起的环境切换要少得多，这一点在服务器应用程序中是很重要的。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a><a href="/tags/性能优化/">性能优化</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	<div class="share-jiathis">
	  
<div class="jiathis_style_24x24">
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_googleplus"></a>
	<a class="jiathis_button_douban"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
    var jiathis_config={
    data_track_clickback:true,
    sm:"copy,renren,cqq",
    pic:"",
    summary:"",
    
  </script> 
<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=
" charset="utf-8"></script>      

	 </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/11/08/数据挖掘中分类与预测的区别/" title="数据挖掘中分类与预测的区别">
  <strong>上一篇：</strong><br/>
  <span>
  数据挖掘中分类与预测的区别</span>
</a>
</div>


<div class="next">
<a href="/2015/10/26/数据挖掘算法与现实生活中的应用案例/"  title="数据挖掘算法与现实生活中的应用案例">
 <strong>下一篇：</strong><br/> 
 <span>数据挖掘算法与现实生活中的应用案例
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/11/01/Java线程池源码解析及高质量代码案例/" data-title="Java线程池源码解析及高质量代码案例" data-url="http://pangjiuzala.github.io/2015/11/01/Java线程池源码解析及高质量代码案例/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java线程池架构原理及源码解析"><span class="toc-number">1.</span> <span class="toc-text">Java线程池架构原理及源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构建参数源码"><span class="toc-number">1.1.</span> <span class="toc-text">构建参数源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参数解释"><span class="toc-number">1.2.</span> <span class="toc-text">参数解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码详细解析"><span class="toc-number">1.3.</span> <span class="toc-text">源码详细解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#excute源码"><span class="toc-number">1.3.1.</span> <span class="toc-text">excute源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addIfUnderCorePoolSize源码"><span class="toc-number">1.3.2.</span> <span class="toc-text">addIfUnderCorePoolSize源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addThread源码"><span class="toc-number">1.3.3.</span> <span class="toc-text">addThread源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadFactory接口默认实现DefaultThreadFactory"><span class="toc-number">1.3.4.</span> <span class="toc-text">ThreadFactory接口默认实现DefaultThreadFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worker的run方法"><span class="toc-number">1.3.5.</span> <span class="toc-text">Worker的run方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getTask源码"><span class="toc-number">1.3.6.</span> <span class="toc-text">getTask源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execute方法部分实现"><span class="toc-number">1.3.7.</span> <span class="toc-text">execute方法部分实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ensureQueuedTaskHandled源码"><span class="toc-number">1.3.8.</span> <span class="toc-text">ensureQueuedTaskHandled源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reject源码"><span class="toc-number">1.3.9.</span> <span class="toc-text">reject源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#再次回到execute方法"><span class="toc-number">1.3.10.</span> <span class="toc-text">再次回到execute方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addIfUnderMaximumPoolSize源码"><span class="toc-number">1.3.11.</span> <span class="toc-text">addIfUnderMaximumPoolSize源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#workerDone源码"><span class="toc-number">1.3.12.</span> <span class="toc-text">workerDone源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runTask(task)源码"><span class="toc-number">1.3.13.</span> <span class="toc-text">runTask(task)源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加任务处理流程"><span class="toc-number">1.4.</span> <span class="toc-text">添加任务处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbortPolicy()"><span class="toc-number">1.4.1.</span> <span class="toc-text">AbortPolicy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CallerRunsPolicy()"><span class="toc-number">1.4.2.</span> <span class="toc-text">CallerRunsPolicy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiscardOldestPolicy()"><span class="toc-number">1.4.3.</span> <span class="toc-text">DiscardOldestPolicy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DiscardPolicy()"><span class="toc-number">1.4.4.</span> <span class="toc-text">DiscardPolicy()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#违反Java高质量代码案例"><span class="toc-number">2.</span> <span class="toc-text">违反Java高质量代码案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#异步运算使用Callable接口"><span class="toc-number">2.1.</span> <span class="toc-text">异步运算使用Callable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优先选择线程池"><span class="toc-number">2.2.</span> <span class="toc-text">优先选择线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程死锁"><span class="toc-number">2.3.</span> <span class="toc-text">线程死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#忽略设置阻塞队列长度"><span class="toc-number">2.4.</span> <span class="toc-text">忽略设置阻塞队列长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用stop方法停止线程"><span class="toc-number">2.5.</span> <span class="toc-text">使用stop方法停止线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#覆写start方法"><span class="toc-number">2.6.</span> <span class="toc-text">覆写start方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用过多线程优先级"><span class="toc-number">2.7.</span> <span class="toc-text">使用过多线程优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock与synchronized"><span class="toc-number">2.8.</span> <span class="toc-text">Lock与synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池异常处理"><span class="toc-number">2.9.</span> <span class="toc-text">线程池异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用SimpleThread类"><span class="toc-number">2.10.</span> <span class="toc-text">使用SimpleThread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程使用不当导致内存溢出"><span class="toc-number">2.11.</span> <span class="toc-text">线程使用不当导致内存溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作队列"><span class="toc-number">2.12.</span> <span class="toc-text">工作队列</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2129798793&verifier=c0951e84&dpc=1"></iframe>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>31</sup></a></li>
			
		
			
				<li><a href="/tags/大数据/" title="大数据">大数据<sup>26</sup></a></li>
			
		
			
				<li><a href="/tags/性能优化/" title="性能优化">性能优化<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/数据挖掘/" title="数据挖掘">数据挖掘<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/HBase/" title="HBase">HBase<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/Hadoop/" title="Hadoop">Hadoop<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/Spark/" title="Spark">Spark<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/数据库/" title="数据库">数据库<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/网络爬虫/" title="网络爬虫">网络爬虫<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/移动互联网/" title="移动互联网">移动互联网<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/物联网/" title="物联网">物联网<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/云平台/" title="云平台">云平台<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Taobao-File-System/" title="Taobao File System">Taobao File System<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/智慧医疗/" title="智慧医疗">智慧医疗<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/爬虫/" title="爬虫">爬虫<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/云计算/" title="云计算">云计算<sup>1</sup></a></li>
			
		
		</ul>
</div>


  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">31</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">25</span></li></ul>
  </div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://blog.csdn.net/pangjiuzala" target="_blank" title="My Blog in  CSDN">CSDN</a>
            
          </li>
        
          <li>
            
            	<a href="http://saliormoon.github.io/" target="_blank" title="王宇峰的博客">王宇峰的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.changhuiyuan.com/" target="_blank" title="常惠源的博客">常惠源的博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="https://github.com/search?q=pangjiuzala&amp;type=Users" target="_blank" title="关注刘兴的github">关注</a>
</div>

  

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello,I&#39;m from ZjuCs! <br/>
			The more you diligent, the more you lucky!</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Copyright@ 2015 Liuxing All rights reserved.
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"pangjiuzala"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'null', 'null');  
ga('send', 'pageview');
</script>



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Ffeafc504b70a541dd3845d467335f367' type='text/javascript'%3E%3C/script%3E"));
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_null'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3Dnull' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<script>
var option = {
  engineKey: '4ac092ad8d749fdc6293'
};
(function(w,d,t,u,n,s,e){
  s = d.createElement(t);
  s.src = u;
  s.async = 1;
  w[n] = function(r){
    w[n].opts = r;
  };
  e = d.getElementsByTagName(t)[0];
  e.parentNode.insertBefore(s, e);
})(window,document,'script','//tinysou-cdn.b0.upaiyun.com/ts.js','_ts');
_ts(option);
</script>

<!-- Tiny_search End -->

  </body>
</html>
